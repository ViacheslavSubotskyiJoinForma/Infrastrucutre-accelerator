<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagram Rendering Tests</title>
    <style>
        body {
            font-family: monospace;
            padding: 2rem;
            background: #1a1a1a;
            color: #f0f0f0;
        }
        .test-result {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .pass {
            background: #1a3a1a;
            color: #4ade80;
        }
        .fail {
            background: #3a1a1a;
            color: #f87171;
        }
        #test-container {
            display: none;
        }
        .summary {
            margin-top: 2rem;
            padding: 1rem;
            background: #2a2a2a;
            border-radius: 8px;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <h1>üß™ Diagram Rendering Tests</h1>
    <div id="test-results"></div>
    <div class="summary" id="summary"></div>

    <!-- Hidden test container -->
    <div id="test-container">
        <svg id="test-diagram" width="100%" height="520"></svg>
        <input type="text" id="test-awsAccountId" value="">
        <select id="test-region">
            <option value="us-east-1">US East 1</option>
        </select>
    </div>

    <script>
        // Mock minimal app.js functions for testing
        const theme = {
            isDark: () => true,
            toggle: () => {}
        };

        let selectedEnvironments = ['dev', 'staging', 'prod'];
        let selectedComponents = ['vpc', 'eks-auto'];
        let selectedProvider = 'aws';

        const defaultCIDRs = {
            'dev': '10.0.0.0/16',
            'staging': '10.1.0.0/16',
            'prod': '10.2.0.0/16'
        };

        function getVPCCIDR(env) {
            return defaultCIDRs[env] || '10.0.0.0/16';
        }

        function calculateSubnetCIDR(vpcCidr, subnetIndex) {
            if (!vpcCidr || !vpcCidr.includes('/')) return '';
            const [baseIp, prefix] = vpcCidr.split('/');
            const octets = baseIp.split('.').map(Number);
            if (prefix === '16') {
                octets[2] = subnetIndex * 16;
                return `${octets.join('.')}/20`;
            }
            return `${baseIp}/20`;
        }

        function addRect(svg, x, y, width, height, fill, stroke, strokeWidth = 2) {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', fill);
            rect.setAttribute('stroke', stroke);
            rect.setAttribute('stroke-width', strokeWidth);
            rect.setAttribute('rx', '8');
            svg.appendChild(rect);
        }

        function addText(svg, x, y, text, weight, anchor, fill) {
            const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textEl.setAttribute('x', x);
            textEl.setAttribute('y', y);
            textEl.setAttribute('text-anchor', anchor);
            textEl.setAttribute('fill', fill);
            textEl.setAttribute('font-weight', weight === 'bold' ? 'bold' : 'normal');
            textEl.setAttribute('font-size',
                weight === 'bold' ? '16' :
                weight === 'small' ? '12' :
                weight === 'tiny' ? '10' : '14'
            );
            textEl.textContent = text;
            svg.appendChild(textEl);
        }

        // Simplified diagram update function for testing
        function updateTestDiagram() {
            const svg = document.getElementById('test-diagram');
            const container = svg.parentElement;
            const envCount = selectedEnvironments.length;
            const hasEKS = selectedComponents.includes('eks-auto');
            const hasRDS = selectedComponents.includes('rds');

            // Calculate viewBox width (matching app.js logic)
            let viewBoxWidth;
            if (envCount === 1) {
                const containerWidth = 800 - 32; // Simulated container width minus padding
                viewBoxWidth = Math.max(containerWidth, 600);
            } else {
                viewBoxWidth = 260 * envCount + 120;
            }

            // Calculate height with proper aspect ratio (matching app.js logic)
            let height;
            if (envCount === 1) {
                height = (hasEKS && hasRDS) ? 650 : (hasEKS || hasRDS) ? 550 : 450;
            } else {
                height = (hasEKS && hasRDS) ? 590 : (hasEKS || hasRDS) ? 490 : 390;
            }

            svg.innerHTML = '';
            svg.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${height}`);

            const colors = {
                envLight: '#374151',
                envProd: '#1e3a5f',
                vpc: '#1f2937',
                text: '#f9fafb',
                textSecondary: '#9ca3af',
                border: {
                    env: '#3b82f6',
                    vpc: '#10b981'
                }
            };

            const outerPadding = 20;
            const outerX = outerPadding;
            const outerY = 60;
            const outerWidth = viewBoxWidth - outerPadding * 2;
            const outerHeight = hasEKS ? 430 : 330;

            // Draw outer container
            addRect(svg, outerX, outerY, outerWidth, outerHeight, 'transparent', colors.border.env, 3);

            const headerY = 20;

            // AWS Logo
            if (selectedProvider === 'aws') {
                const logoX = 35;
                const logoY = headerY - 2;
                const logoWidth = 28;
                const logoHeight = 16;

                const smile = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const smileStart = `M ${logoX},${logoY + logoHeight * 0.4}`;
                const smileCurve = `Q ${logoX + logoWidth/2},${logoY + logoHeight * 0.95} ${logoX + logoWidth},${logoY + logoHeight * 0.4}`;
                smile.setAttribute('d', `${smileStart} ${smileCurve}`);
                smile.setAttribute('stroke', '#FF9900');
                smile.setAttribute('stroke-width', '2.8');
                smile.setAttribute('fill', 'none');
                smile.setAttribute('stroke-linecap', 'round');
                smile.setAttribute('data-test', 'aws-logo-smile');
                svg.appendChild(smile);

                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const arrowTipX = logoX + logoWidth;
                const arrowTipY = logoY + logoHeight * 0.4;
                arrow.setAttribute('points', `${arrowTipX - 3},${arrowTipY - 3.5} ${arrowTipX + 3},${arrowTipY} ${arrowTipX - 3},${arrowTipY + 3.5}`);
                arrow.setAttribute('fill', '#FF9900');
                arrow.setAttribute('data-test', 'aws-logo-arrow');
                svg.appendChild(arrow);
            }

            // Title
            addText(svg, 70, headerY + 5, 'AWS Cloud Architecture', 'bold', 'start', colors.text);

            // Account ID and Region
            const awsAccountId = document.getElementById('test-awsAccountId').value.trim();
            const region = document.getElementById('test-region').value;

            if (awsAccountId && region) {
                const detailsText = `Account: ${awsAccountId} | Region: ${region}`;
                const detailsEl = addText(svg, 70, headerY + 22, detailsText, 'tiny', 'start', colors.textSecondary);
            }

            // Draw environments with equal spacing
            const innerPadding = 20;
            const envGap = 10;
            const availableWidth = outerWidth - innerPadding * 2;
            const totalGaps = Math.max(0, (envCount - 1) * envGap);
            const envWidth = (availableWidth - totalGaps) / envCount;

            selectedEnvironments.forEach((env, i) => {
                const x = outerX + innerPadding + i * (envWidth + envGap);
                const y = outerY + 50;
                const boxHeight = hasEKS ? 340 : 240;
                const envBoxWidth = envWidth;

                // Mark first and last environments for testing
                const rect = addRect(svg, x, y, envBoxWidth, boxHeight, colors.envLight, colors.border.env);
                if (i === 0) svg.lastChild.setAttribute('data-test', 'first-env');
                if (i === envCount - 1) svg.lastChild.setAttribute('data-test', 'last-env');

                addText(svg, x + envBoxWidth / 2, y + 20, env.toUpperCase(), 'bold', 'middle', colors.text);
            });

            // Store dimensions for testing
            svg.setAttribute('data-outer-x', outerX);
            svg.setAttribute('data-outer-width', outerWidth);
            svg.setAttribute('data-inner-padding', innerPadding);
            svg.setAttribute('data-env-width', envWidth);
            svg.setAttribute('data-env-gap', envGap);
        }

        // Test suite
        const tests = [
            {
                name: 'Equal spacing: Left padding equals right padding',
                run: () => {
                    selectedEnvironments = ['dev', 'staging', 'prod'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const outerX = parseFloat(svg.getAttribute('data-outer-x'));
                    const outerWidth = parseFloat(svg.getAttribute('data-outer-width'));
                    const innerPadding = parseFloat(svg.getAttribute('data-inner-padding'));
                    const envWidth = parseFloat(svg.getAttribute('data-env-width'));
                    const envGap = parseFloat(svg.getAttribute('data-env-gap'));
                    const envCount = selectedEnvironments.length;

                    const firstEnv = svg.querySelector('[data-test="first-env"]');
                    const lastEnv = svg.querySelector('[data-test="last-env"]');

                    const firstEnvX = parseFloat(firstEnv.getAttribute('x'));
                    const lastEnvX = parseFloat(lastEnv.getAttribute('x'));
                    const lastEnvWidth = parseFloat(lastEnv.getAttribute('width'));

                    const leftPadding = firstEnvX - outerX;
                    const rightEdge = outerX + outerWidth;
                    const lastEnvRightEdge = lastEnvX + lastEnvWidth;
                    const rightPadding = rightEdge - lastEnvRightEdge;

                    // Allow 1px tolerance for rounding
                    return Math.abs(leftPadding - rightPadding) <= 1;
                }
            },
            {
                name: 'Equal spacing: Inner padding is 20px on both sides',
                run: () => {
                    selectedEnvironments = ['dev', 'staging'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const innerPadding = parseFloat(svg.getAttribute('data-inner-padding'));

                    return innerPadding === 20;
                }
            },
            {
                name: 'AWS logo: Smile path is fully visible within viewBox',
                run: () => {
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const smile = svg.querySelector('[data-test="aws-logo-smile"]');

                    if (!smile) return false;

                    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
                    const [vbX, vbY, vbWidth, vbHeight] = viewBox;

                    // Parse path to get coordinates
                    const d = smile.getAttribute('d');
                    const coords = d.match(/[\d.]+/g).map(Number);

                    // Check all coordinates are within viewBox
                    for (let i = 0; i < coords.length; i += 2) {
                        const x = coords[i];
                        const y = coords[i + 1];
                        if (x < vbX || x > vbX + vbWidth || y < vbY || y > vbY + vbHeight) {
                            return false;
                        }
                    }

                    return true;
                }
            },
            {
                name: 'AWS logo: Arrow is fully visible within viewBox',
                run: () => {
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const arrow = svg.querySelector('[data-test="aws-logo-arrow"]');

                    if (!arrow) return false;

                    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
                    const [vbX, vbY, vbWidth, vbHeight] = viewBox;

                    // Parse points
                    const points = arrow.getAttribute('points').split(' ');
                    for (const point of points) {
                        const [x, y] = point.split(',').map(Number);
                        if (x < vbX || x > vbX + vbWidth || y < vbY || y > vbY + vbHeight) {
                            return false;
                        }
                    }

                    return true;
                }
            },
            {
                name: 'Theme switch: SVG viewBox dimensions remain constant',
                run: () => {
                    selectedEnvironments = ['dev', 'staging'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const viewBox1 = svg.getAttribute('viewBox');

                    // Simulate theme change (diagram should use container width, not svg clientWidth)
                    updateTestDiagram();

                    const viewBox2 = svg.getAttribute('viewBox');

                    return viewBox1 === viewBox2;
                }
            },
            {
                name: 'Real-time updates: Account ID appears on diagram',
                run: () => {
                    const accountInput = document.getElementById('test-awsAccountId');
                    accountInput.value = '987654321098';

                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const svgContent = svg.innerHTML;

                    return svgContent.includes('987654321098');
                }
            },
            {
                name: 'Real-time updates: Region appears on diagram',
                run: () => {
                    const regionSelect = document.getElementById('test-region');
                    regionSelect.value = 'us-east-1';

                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const svgContent = svg.innerHTML;

                    return svgContent.includes('us-east-1');
                }
            },
            {
                name: 'Real-time updates: Account and Region combined correctly',
                run: () => {
                    const accountInput = document.getElementById('test-awsAccountId');
                    const regionSelect = document.getElementById('test-region');

                    accountInput.value = '111111111111';
                    regionSelect.value = 'us-east-1';

                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const svgContent = svg.innerHTML;

                    return svgContent.includes('Account: 111111111111 | Region: us-east-1');
                }
            },
            {
                name: 'Environment gaps: Consistent 10px gaps between environments',
                run: () => {
                    selectedEnvironments = ['dev', 'staging', 'prod'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const envGap = parseFloat(svg.getAttribute('data-env-gap'));

                    return envGap === 10;
                }
            },
            {
                name: 'Diagram height: Fixed at 520px (legacy test - will be updated)',
                run: () => {
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
                    const height = viewBox[3];

                    // This test validates the old fixed height logic
                    // New logic: single env has taller height, multi-env has original heights
                    return height === 520 || height === 450 || height === 550 || height === 650;
                }
            },
            {
                name: 'Single environment: Taller diagram than multi-environment',
                run: () => {
                    // Test single environment height
                    selectedEnvironments = ['dev'];
                    selectedComponents = ['vpc'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const viewBox1 = svg.getAttribute('viewBox').split(' ').map(Number);
                    const singleEnvHeight = viewBox1[3];

                    // Test multi-environment height
                    selectedEnvironments = ['dev', 'staging'];
                    updateTestDiagram();

                    const viewBox2 = svg.getAttribute('viewBox').split(' ').map(Number);
                    const multiEnvHeight = viewBox2[3];

                    // Single env should be taller (450 vs 390 for base VPC)
                    return singleEnvHeight > multiEnvHeight;
                }
            },
            {
                name: 'Single environment with EKS: Proper height adjustment',
                run: () => {
                    selectedEnvironments = ['dev'];
                    selectedComponents = ['vpc', 'eks-auto'];
                    updateTestDiagram();

                    const svg = document.getElementById('test-diagram');
                    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
                    const height = viewBox[3];

                    // Single env with EKS should have height of 550
                    return height === 550;
                }
            }
        ];

        // Run tests
        function runTests() {
            let passed = 0;
            let failed = 0;
            const resultsDiv = document.getElementById('test-results');

            tests.forEach((test, i) => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'test-result';

                let success = false;
                let error = null;

                try {
                    success = test.run();
                } catch (e) {
                    error = e.message;
                    success = false;
                }

                if (success) {
                    passed++;
                    resultDiv.classList.add('pass');
                    resultDiv.textContent = `‚úÖ Test ${i + 1}: ${test.name}`;
                } else {
                    failed++;
                    resultDiv.classList.add('fail');
                    resultDiv.textContent = `‚ùå Test ${i + 1}: ${test.name}${error ? ` (${error})` : ''}`;
                }

                resultsDiv.appendChild(resultDiv);
            });

            const summary = document.getElementById('summary');
            summary.innerHTML = `
                <strong>üìä Results:</strong> ${passed}/${tests.length} passed, ${failed} failed<br>
                ${failed === 0 ? '<strong style="color: #4ade80;">‚úÖ All tests passed!</strong>' : '<strong style="color: #f87171;">‚ùå Some tests failed</strong>'}
            `;
        }

        // Run tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html>
